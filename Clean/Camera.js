// Generated by LiveScript 1.3.1
(function(){
  var Main;
  Main = {};
  Main.Init = function(){
    var ref$, _, Pure, MaxMatch, GetCameraId, FindWebCam, errorFn, linkFn, ClearOldTimeout, Loop, MeasureTime, CreateGrid, Brown;
    ref$ = require("./headers.js"), _ = ref$._, Pure = ref$.Pure, MaxMatch = ref$.MaxMatch;
    this.createObjectURL = window.URL.createObjectURL || window.webkitURL.createObjectURL;
    this.GetUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    this.VideoElement = null;
    this.DummyCanvas = null;
    this.ViewCanvas = null;
    this.DummyCTX = null;
    this.ViewCTX = null;
    this.CurrentTimeout = null;
    this.UpdateStatusTimeout = null;
    this.List = new Uint8Array(new ArrayBuffer(640 * 480));
    this.Index = new Uint32Array(new ArrayBuffer(4 * 50000));
    this.PreviousListOfCentroids = [];
    this.HistoryX = [];
    this.HistoryY = [];
    this.HistoryNull = [];
    this.InitialSetUp = false;
    this.ShowOnlyCamera = false;
    this.TableOfInput = null;
    this.RefToTime = null;
    this.Frames = 0;
    this.Acum = 0;
    this.StatusTable = null;
    this.round = Math.round;
    this.m = null;
    this.HideGraphForPerformance = false;
    this.ListOfCamera = [];
    this.ShowGrid = false;
    this.XorYorXY = "X";
    this.Division = null;
    this.SizeOfRect = 3;
    this.SetTableValues = function(){
      var TableOfInput;
      TableOfInput = Main.TableOfInput;
      Main.RowLookUp = TableOfInput[2]();
      Main.MaximumRadiusOfPin = TableOfInput[3]();
      Main.Luminosity = TableOfInput[4]();
      Main.StartId = TableOfInput[5]();
      Main.EndId = TableOfInput[6]();
      Main.StartX = TableOfInput[7]();
      Main.EndX = TableOfInput[8]();
      Main.StartY = TableOfInput[9]();
      Main.EndY = TableOfInput[10]();
      Main.EndFrame = TableOfInput[11]();
    };
    this.SetXorYorXY = function(value){
      Main.HideGraphForPerformance = false;
      Main.ShowGrid = true;
      Main.ShowOnlyCamera = false;
      Main.XorYorXY = value;
    };
    GetCameraId = function(x, index){
      var label;
      label = x.label;
      if (label === "") {
        label = "Camera " + (index + 1);
      }
      return {
        label: label,
        id: x.id
      };
    };
    FindWebCam = function(x){
      Main.ListOfCamera = _.map(_.filter(x, function(it){
        return it.kind === "video";
      }), GetCameraId);
    };
    this.HideEverything = function(){
      Main.HideGraphForPerformance = true;
      Main.ViewCTX.clearRect(0, 0, 640, 480);
    };
    this.GetCamera = function(){
      MediaStreamTrack.getSources(function(x){
        return FindWebCam(x);
      });
    };
    errorFn = function(e){
      return console.log("Coudn't Stream from WebCam");
    };
    linkFn = function(stream){
      this.VideoElement.src = "./test2.webm";
      this.VideoElement.play();
    }.bind(this);
    this.AttachCameraToVideoElement = function(Index){
      var options;
      options = {
        video: {
          optional: [{
            sourceId: this.ListOfCamera[Index]
          }]
        },
        audio: false
      };
      this.GetUserMedia.call(navigator, options, linkFn, errorFn);
    };
    this.InitCTX = function(Ref, refCTX){
      var Vctx;
      Vctx = Ref.getContext("2d");
      Vctx.canvas.height = 480;
      Vctx.canvas.width = 640;
      Main[refCTX] = Vctx;
    };
    ClearOldTimeout = function(){
      if (Main.CurrentTimeout !== null) {
        clearTimeout(Main.CurrentTimeout);
      }
      if (Main.UpdateStatusTimeout !== null) {
        clearTimeout(Main.UpdateStatusTimeout);
      }
    };
    this.AttachVideoElementToViewCanvas = function(){
      ClearOldTimeout();
      Main.CurrentTimeout = setTimeout(Main.AttachVideoElementToViewCanvas, 35);
      Main.ViewCTX.drawImage(Main.VideoElement, 0, 0, 640, 480);
    };
    Loop = function(){
      var Start, Index, List, Dctx, ctx, imageData, MaximumRadiusOfPin, I, CurrentListOfCentroids, NumberOfPins, K;
      Main.CurrentTimeout = setTimeout(Loop, 35);
      Start = new Date().getTime();
      Index = Main.Index;
      List = Main.List;
      Dctx = Main.DummyCTX;
      ctx = Main.ViewCTX;
      Dctx.drawImage(Main.VideoElement, 0, 0, 640, 480);
      imageData = Dctx.getImageData(0, 0, 640, 480);
      Pure.WriteToList(imageData.data, List);
      MaximumRadiusOfPin = Main.MaximumRadiusOfPin;
      I = Pure.FindIndex(List, Index, MaximumRadiusOfPin, Main.Luminosity);
      CurrentListOfCentroids = [];
      Pure.ReduceRowDimensionality(Index, I, CurrentListOfCentroids, Main.RowLookUp, MaximumRadiusOfPin);
      NumberOfPins = CurrentListOfCentroids.length;
      if (NumberOfPins > 350) {
        Main.StatusTable[1](NumberOfPins);
        if (Main.InitialSetUp) {
          K = MaxMatch.TrackIDs(Main.PreviousListOfCentroids, CurrentListOfCentroids);
          MaxMatch.KeepHistory(Main.HistoryX, Main.HistoryY, Main.HistoryNull, Main.PreviousListOfCentroids);
          Main.StatusTable[0](K);
        } else {
          Main.PreviousListOfCentroids = MaxMatch.AssignIDs(CurrentListOfCentroids);
          MaxMatch.InitHistory(Main.HistoryX, Main.HistoryY, Main.HistoryNull, Main.PreviousListOfCentroids.length);
          Main.InitialSetUp = true;
        }
      }
      if (!Main.HideGraphForPerformance) {
        if (Main.ShowOnlyCamera === false) {
          if (Main.ShowGrid) {
            Dctx.clearRect(0, 0, 640, 480);
            ctx.clearRect(0, 0, 640, 480);
            if (Main.XorYorXY === "XY") {
              Main.DrawXY(Main.PreviousListOfCentroids);
            } else {
              Main.DrawEachLine();
            }
          } else {
            Pure.DrawOnCanvas(Main.PreviousListOfCentroids, Dctx);
          }
        }
        ctx.drawImage(Main.DummyCanvas, 0, 0);
      }
      Main.Acum += new Date().getTime() - Start;
      Main.Frames += 1;
    };
    MeasureTime = function(){
      var MillisecondFn, OldTime, newTime;
      Main.UpdateStatusTimeout = setTimeout(MeasureTime, 1000);
      MillisecondFn = Main.StatusTable[2];
      OldTime = MillisecondFn();
      newTime = (Main.Acum / Main.Frames).toFixed(1);
      if (OldTime !== newTime) {
        MillisecondFn(newTime);
        if (app.StopRedraw === false) {
          Main.m.redraw();
        }
      }
      Main.Acum = 0;
      Main.Frames = 0;
    };
    this.StartTracking = function(){
      if (Main.VideoElement.src === "") {
        return;
      }
      ClearOldTimeout();
      Loop();
      MeasureTime();
    };
    this.StopTracking = function(){
      ClearOldTimeout();
      Main.StatusTable[2](0);
      Main.StatusTable[1](0);
      Main.AttachVideoElementToViewCanvas();
      Main.InitialSetUp = false;
    };
    this.ShowOnlyCameraFeed = function(){
      Main.ShowGrid = false;
      Main.HideGraphForPerformance = false;
      Main.ShowOnlyCamera = true;
    };
    this.ChangeShowOnlyCamera = function(){
      Main.HideGraphForPerformance = false;
      Main.ShowOnlyCamera = false;
    };
    this.ShowOnlyPins = function(){
      Main.HideGraphForPerformance = false;
      Main.ShowOnlyCamera = false;
      Main.ShowGrid = false;
    };
    this.CreateLine = function(start, end, ctx){
      ctx.beginPath();
      ctx.moveTo(start[0], start[1]);
      ctx.lineTo(end[0], end[1]);
      ctx.stroke();
    };
    CreateGrid = function(divisionsX, divisionsY, ctx){
      var I, ResY, ResX, Start, End, CreateLine;
      I = 0;
      ResY = 480 / divisionsY;
      ResX = 640 / divisionsX;
      Start = [0, 0];
      End = [640, 0];
      CreateLine = Main.CreateLine;
      while (I < divisionsY) {
        CreateLine(Start, End, ctx);
        Start[1] += ResY;
        End[1] += ResY;
        I += 1;
      }
      I = 0;
      Start = [0, 0];
      End = [0, 480];
      while (I < divisionsX) {
        CreateLine(Start, End, ctx);
        Start[0] += ResX;
        End[0] += ResX;
        I += 1;
      }
    };
    this.DrawGrid = function(){
      var DC, Dctx, ctx;
      DC = Main.DummyCanvas;
      Dctx = Main.DummyCTX;
      ctx = Main.ViewCTX;
      Dctx.clearRect(0, 0, 640, 480);
      ctx.clearRect(0, 0, 640, 480);
      Dctx.strokeStyle = "#D4D4D4";
      Dctx.lineWidth = 0.5;
    };
    this.DrawLine = function(Dctx, Id, History, Division, EndFrame){
      var I, Current, X, Y;
      I = 0;
      while (I < EndFrame) {
        Current = History[I][200];
        X = Current[0];
        Y = Current[1];
        Dctx.lineTo(I * Division, Y);
        Dctx.stroke();
        I += 1;
      }
    };
    Brown = "#80392E";
    this.DrawXY = function(PreviousListOfCentroids){
      var Dctx, StartId, EndId, StartX, EndX, StartY, EndY, Red, Green, len, I, XDiff, YDiff, XScale, YScale, PixelSize, Horizontal, Vertical, Current, ID, X, Y, Null;
      Dctx = Main.DummyCTX;
      StartId = Main.StartId;
      EndId = Main.EndId;
      StartX = Main.StartX;
      EndX = Main.EndX;
      StartY = Main.StartY;
      EndY = Main.EndY;
      Red = "#C43F3F";
      Green = "#72C43F";
      len = PreviousListOfCentroids.length;
      I = 0;
      XDiff = EndX - StartX;
      YDiff = EndY - StartY;
      XScale = 640 / XDiff;
      YScale = 480 / YDiff;
      PixelSize = 3;
      if (XScale > YScale) {
        PixelSize = YScale * 4;
      } else {
        PixelSize = XScale * 4;
      }
      Horizontal = 120 / XScale;
      Vertical = 100 / YScale;
      Dctx.strokeStyle = "#D4D4D4";
      Dctx.lineWidth = 0.5;
      CreateGrid(Horizontal, Vertical, Dctx);
      while (I < len) {
        Current = PreviousListOfCentroids[I];
        ID = Current[0];
        X = Current[1];
        Y = Current[2];
        Null = Current[3];
        if ((StartId < ID && ID < EndId) && (StartX < X && X < EndX) && (StartY < Y && Y < EndY)) {
          if (Null) {
            Dctx.fillStyle = Red;
          } else {
            Dctx.fillStyle = Green;
          }
          Dctx.fillRect((X - StartX) * XScale, (Y - StartY) * YScale, PixelSize, PixelSize);
        }
        I += 1;
      }
    };
    this.DrawEachLine = function(){
      var Dctx, ctx, StartId, EndId, StartX, EndX, StartY, EndY, EndFrame, X, Y, Red, Green, HistoryNull, ScaleFactor, Transform, History, Diff, Division, Horizontal, Vertical, I, Current, len, CurrentNull, K;
      Dctx = Main.DummyCTX;
      ctx = Main.ViewCTX;
      StartId = Main.StartId;
      EndId = Main.EndId;
      StartX = Main.StartX;
      EndX = Main.EndX;
      StartY = Main.StartY;
      EndY = Main.EndY;
      EndFrame = Main.EndFrame;
      Dctx.lineWidth = 1;
      X = 0;
      Y = 0;
      Red = "#C43F3F";
      Green = "#72C43F";
      HistoryNull = Main.HistoryNull;
      ScaleFactor = 1;
      Transform = 0;
      if (Main.XorYorXY === "X") {
        History = Main.HistoryX;
        Transform = StartX;
        Diff = EndX - Transform;
      }
      if (Main.XorYorXY === "Y") {
        History = Main.HistoryY;
        Transform = StartY;
        Diff = EndY - Transform;
      }
      ScaleFactor = 480 / Diff;
      if (History[0].length < EndFrame) {
        EndFrame = History[0].length;
      }
      if (EndFrame > 300) {
        EndFrame = 300;
      }
      Division = 640 / (EndFrame - 0.9);
      Dctx.strokeStyle = "#D4D4D4";
      Dctx.lineWidth = 0.5;
      Horizontal = EndFrame / 4;
      Vertical = 100 / ScaleFactor;
      CreateGrid(Horizontal, Vertical, Dctx);
      Dctx.lineWidth = 1;
      I = StartId;
      while (I < EndId) {
        Current = History[I];
        len = Current.length;
        CurrentNull = HistoryNull[I][len - 1];
        X = Main.HistoryX[I][len - 1];
        Y = Main.HistoryY[I][len - 1];
        Dctx.beginPath();
        if ((StartX < X && X < EndX) && (StartY < Y && Y < EndY)) {
          if (CurrentNull) {
            Dctx.strokeStyle = Red;
          } else {
            Dctx.strokeStyle = Green;
          }
          K = 0;
          while (K < len) {
            X = (Current[K] - Transform) * ScaleFactor;
            Y = K * Division;
            Dctx.lineTo(Y, X);
            K += 1;
          }
          Dctx.stroke();
        }
        I += 1;
      }
    };
  };
  Main.Init();
  window.Camera = Main;
}).call(this);
