// Generated by LiveScript 1.3.1
(function(){
  var Main, _, reshape, FindBestIndex, MatchEachList, ForEachElem, LookUpElem;
  Main = {};
  Main.abs = Math.abs;
  Main.sqrt = Math.sqrt;
  Main.round = Math.round;
  _ = require("lodash")._;
  Main.AssignIds = function(List){
    _.each(List, function(x, index){
      return x[2] = index;
    });
    return 0;
  };
  Main.CheckNear = function(First, Second){
    var abs, lenFirst, lenSecond, FinalArray, ConfusedArray, I, MainElem, K, LastElem, PushingElem, Push, CheckElem, total, e, cloned;
    abs = Math.abs;
    lenFirst = First.length;
    lenSecond = Second.length;
    FinalArray = [];
    ConfusedArray = [];
    I = 0;
    while (I < lenSecond) {
      MainElem = Second[I];
      K = 0;
      LastElem = [null, null, null, Infinity];
      PushingElem = [];
      Push = false;
      while (K < lenFirst) {
        try {
          CheckElem = First[K];
          total = 0;
          total += abs(CheckElem[0] - MainElem[0]);
          total += abs(CheckElem[1] - MainElem[1]);
        } catch (e$) {
          e = e$;
          console.log("problem : " + First[K] + " : " + MainElem);
          console.log("K : " + K);
          console.log("SizeOfOld : " + First.length);
          console.log("SizeOfNew : " + Second.length);
          throw "stop";
        }
        if (total < 3) {
          FinalArray.push([Second[I][0], Second[I][1], CheckElem[2]]);
          Push = false;
          break;
        } else if (total < LastElem[3]) {
          Push = true;
          cloned = CheckElem.slice(0);
          cloned.push(total);
          PushingElem = [LastElem, cloned];
          LastElem = cloned.slice(0);
        }
        K += 1;
      }
      if (Push) {
        ConfusedArray.push([MainElem[0], MainElem[1], PushingElem]);
      }
      I += 1;
    }
    return {
      FinalArray: FinalArray,
      ConfusedArray: ConfusedArray
    };
  };
  Main.FilterFn = function(X, Threshold){
    if (X[2][0][3] > Threshold && X[2][1][3] > Threshold) {
      return false;
    } else {
      return true;
    }
  };
  Main.CombineClosedOnes = function(ConfusedArray, ListOfIds){
    var abs, min, I, len, SizeOfListOfIds, Elem, NumberOfNeighbours, K, Found, IdToMatch, J;
    abs = Math.abs;
    min = Math.min;
    I = 0;
    len = ConfusedArray.length;
    SizeOfListOfIds = ListOfIds.length;
    while (I < len) {
      Elem = ConfusedArray[I][2];
      Elem = _.sortBy(Elem, fn$);
      NumberOfNeighbours = 2;
      K = 0;
      Found = false;
      while (K < NumberOfNeighbours) {
        IdToMatch = Elem[K][2];
        J = 0;
        Found = false;
        while (J < SizeOfListOfIds) {
          if (IdToMatch === ListOfIds[J]) {
            Found = true;
            break;
          }
          J += 1;
        }
        if (!Found) {
          ConfusedArray[I][2] = IdToMatch;
          ListOfIds.push(IdToMatch);
          break;
        }
        K += 1;
      }
      if (Found === true) {
        ConfusedArray[I][2] = null;
      }
      I += 1;
    }
    return ListOfIds;
    function fn$(x){
      return x[3];
    }
  };
  Main.AssignIDForNextFrame = function(Last, Next, Threshold){
    var ref$, FinalArray, ConfusedArray, ListOfIds, CombinedFinalList;
    Threshold == null && (Threshold = 18);
    ref$ = Main.CheckNear(Last, Next), FinalArray = ref$.FinalArray, ConfusedArray = ref$.ConfusedArray;
    ConfusedArray = _.filter(ConfusedArray, function(X){
      return Main.FilterFn(X, Threshold);
    });
    ListOfIds = _.map(FinalArray, function(x){
      return x[2];
    });
    Main.CombineClosedOnes(ConfusedArray, ListOfIds);
    CombinedFinalList = FinalArray.concat(ConfusedArray);
    return CombinedFinalList;
  };
  reshape = function(vector, Divs){
    var len, I, Final, next;
    len = vector.length;
    I = 0;
    Final = [];
    while (I < len) {
      next = I + Divs;
      Final.push(vector.slice(I, next));
      I = next;
    }
    return Final;
  };
  FindBestIndex = function(List, LookUpVal, Pos, MaxNumberOfElementInSpace){
    MaxNumberOfElementInSpace == null && (MaxNumberOfElementInSpace = 5);
    return [0, List.length];
  };
  MatchEachList = function(Unique, PositionGraph, Pos){
    var NumberTooFar, len, I, abs, y, Indexes, K, total, PreviousTotal, MaxKFound;
    NumberTooFar = 0;
    len = Unique.length;
    I = 0;
    abs = Math.abs;
    while (I < len) {
      y = Unique[I][Pos];
      Indexes = FindBestIndex(PositionGraph, y, Pos, 600);
      K = Indexes[0];
      total = 0;
      PreviousTotal = Infinity;
      MaxKFound = null;
      while (K < Indexes[1]) {
        total = 0;
        total += abs(PositionGraph[K][0] - Unique[I][0]);
        total += abs(PositionGraph[K][1] - Unique[I][1]);
        if (total < PreviousTotal) {
          PreviousTotal = total;
          MaxKFound = K;
        }
        K += 1;
      }
      Unique[I][2] = MaxKFound;
      Unique[I][3] = PreviousTotal;
      Unique[I][4] = "";
      I += 1;
    }
  };
  ForEachElem = function(ElemIndex, First, Second, Range, JumpAmount){
    var Elem, InitialI, x, y, abs, SecondLen, XLowerBound, XUpperBound, XValueAtSecond, Amount, LowestDistance, LowestDistanceIndex, Total, I;
    Elem = First[ElemIndex];
    InitialI = ElemIndex;
    x = Elem[0];
    y = Elem[1];
    abs = Math.abs;
    SecondLen = Second.length;
    XLowerBound = x - Range;
    XUpperBound = x + Range;
    if (InitialI >= SecondLen) {
      InitialI = SecondLen - 1;
    }
    XValueAtSecond = Second[InitialI][0];
    Amount = JumpAmount;
    if (XValueAtSecond < XLowerBound) {
      while (XValueAtSecond <= XLowerBound) {
        InitialI += Amount;
        XValueAtSecond = Second[InitialI][0];
      }
    }
    if (XValueAtSecond > XUpperBound) {
      while (XValueAtSecond >= XUpperBound) {
        InitialI -= Amount;
        XValueAtSecond = Second[InitialI][0];
      }
    }
    LowestDistance = Infinity;
    LowestDistanceIndex = 0;
    Total = 0;
    I = InitialI;
    while ((XLowerBound <= XValueAtSecond && XValueAtSecond <= XUpperBound) && 0 < I) {
      Total += abs(Second[I][1] - y);
      Total += abs(Second[I][0] - x);
      if (Total < LowestDistance) {
        LowestDistance = Total;
        LowestDistanceIndex = I;
      }
      Total = 0;
      I -= 1;
      XValueAtSecond = Second[I][0];
    }
    I = InitialI + 1;
    Total = 0;
    while ((XLowerBound <= XValueAtSecond && XValueAtSecond <= XUpperBound) && I < SecondLen) {
      Total += abs(Second[I][1] - y);
      Total += abs(Second[I][0] - x);
      if (Total < LowestDistance) {
        LowestDistance = Total;
        LowestDistanceIndex = I;
      }
      Total = 0;
      I += 1;
      XValueAtSecond = Second[I][0];
    }
    return [LowestDistanceIndex, LowestDistance];
  };
  LookUpElem = function(First, Elem, TestNull){
    var len, I, MaxTotal, Index, Total, Second, Graph, PredictiveIndex, List, Switched, NextGraph, CurrentIndex, nextIndex, NextNextIndex, K, p1, p2, len2, OdOrEv, Top, Bottom, Close, CloseElem, Vx, Vy;
    TestNull == null && (TestNull = false);
    len = First.length;
    I = 0;
    MaxTotal = Infinity;
    Index = null;
    while (I < len) {
      if (First[I] === undefined) {
        I += 1;
        continue;
      }
      Total = 0;
      Total += Math.abs(Elem[0] - First[I][0]);
      Total += Math.abs(Elem[1] - First[I][1]);
      if (Total < MaxTotal) {
        if (TestNull === true && First[I][3] === null) {
          I += 1;
          continue;
        }
        MaxTotal = Total;
        Index = I;
      }
      I += 1;
    }
    return Index;
    First = _.sortBy(First, function(x){
      return x[0];
    });
    Second = _.sortBy(Second, function(x){
      return x[0];
    });
    _.each(First, function(x, index){
      var next;
      next = LookUpElem(Second, x);
      x[2] = next;
      x[3] = null;
    });
    _.each(Second, function(x, index){
      var next;
      next = LookUpElem(First, x);
      x[2] = next;
      x[3] = null;
    });
    len = First.length;
    I = 0;
    Graph = [First, Second];
    PredictiveIndex = [];
    while (I < len) {
      List = [];
      Switched = 0;
      NextGraph = (Switched + 1) % 2;
      CurrentIndex = I;
      if (Graph[Switched][CurrentIndex][3] !== null) {
        I += 1;
        continue;
      }
      nextIndex = Graph[Switched][CurrentIndex][2];
      NextNextIndex = Graph[NextGraph][nextIndex][2];
      K = 0;
      for (;;) {
        if (K > 2000) {
          console.log("This Array");
          return;
        }
        K += 1;
        if (NextNextIndex === CurrentIndex) {
          p1 = Graph[NextGraph][nextIndex];
          p2 = Graph[Switched][CurrentIndex];
          p1[2] = p1[0];
          p1[3] = p1[1];
          p2[2] = p2[0];
          p2[3] = p2[1];
          p1[0] = p2[2];
          p1[1] = p2[3];
          p2[0] = p1[2];
          p2[1] = p1[3];
          break;
        } else {
          Switched = NextGraph;
          NextGraph = (Switched + 1) % 2;
          List.push([CurrentIndex, NextGraph]);
          CurrentIndex = nextIndex;
          nextIndex = Graph[Switched][CurrentIndex][2];
          NextNextIndex = Graph[NextGraph][nextIndex][2];
        }
      }
      len2 = List.length;
      if (len2 > 0) {
        K = 0;
        OdOrEv = len2 % 2;
        if (OdOrEv === 1) {
          PredictiveIndex.push(List.shift());
        }
        len2 -= 1;
        while (K < len2) {
          Top = List.pop();
          Bottom = List.pop();
          p1 = Graph[Top[1]][Top[0]];
          p2 = Graph[Bottom[1]][Bottom[0]];
          p1[2] = p1[0];
          p1[3] = p1[1];
          p2[2] = p2[0];
          p2[3] = p2[1];
          p1[0] = p2[2];
          p1[1] = p2[3];
          p2[0] = p1[2];
          p2[1] = p1[3];
          K += 2;
        }
      }
      I += 1;
    }
    len = PredictiveIndex.length;
    I = 0;
    while (I < len) {
      Elem = First[PredictiveIndex[I][0]];
      Close = LookUpElem(First, Elem, true);
      CloseElem = First[Close];
      Vx = CloseElem[0] - CloseElem[2];
      Vy = CloseElem[1] - CloseElem[3];
      Elem[2] = Elem[0];
      Elem[3] = Elem[1];
      Elem[0] = Elem[2] + Vx;
      Elem[1] = Elem[3] + Vy;
      I += 1;
    }
    return First;
  };
  Main.AssignIds = function(List){
    return _.each(List, function(x, index){
      x[4] = index;
    });
  };
  Main.AssignIDs = function(First){
    var len, I, List, ID, x, y;
    len = First.length;
    I = 0;
    List = [];
    List;
    while (I < len) {
      ID = I;
      x = First[I][0];
      y = First[I][1];
      List.push([ID, x, y, null, null, null, x, y]);
      I += 1;
    }
    return List;
  };
  Main.FindStart = function(Index, LowerBound, Second, JumpAmount){
    var I, len, SecondInitialX;
    I = Index;
    len = Second.length;
    if (!(I < len)) {
      I = len - 1;
    }
    SecondInitialX = Second[I][0];
    if (SecondInitialX < LowerBound) {
      while (SecondInitialX <= LowerBound) {
        I += JumpAmount;
        if (I < len) {
          SecondInitialX = Second[I][0];
        } else {
          return len - 1;
        }
      }
    } else {
      while (SecondInitialX >= LowerBound) {
        I -= JumpAmount;
        if (I < 0) {
          return 0;
        }
        SecondInitialX = Second[I][0];
      }
    }
    return I;
  };
  Main.FindClosestElem = function(Index, Range, First, Second){
    var abs, sqrt, round, Elem, ElemXVal, ElemYVal, LowerBoundX, UpperBoundX, I, CurrentXVal, MaxTotal, len, CurrentYVal, Total, e1, e2, EndIndex;
    abs = this.abs;
    sqrt = this.sqrt;
    round = this.round;
    Elem = First[Index];
    ElemXVal = Elem[1];
    ElemYVal = Elem[2];
    LowerBoundX = ElemXVal - Range;
    UpperBoundX = ElemXVal + Range;
    I = this.FindStart(Index, LowerBoundX, Second, 3);
    CurrentXVal = Second[I][0];
    MaxTotal = Infinity;
    len = Second.length;
    while (CurrentXVal <= UpperBoundX && I < len) {
      CurrentXVal = Second[I][0];
      CurrentYVal = Second[I][1];
      if (!(Second[I][2] === null)) {
        Total = 0;
        e1 = ElemXVal - CurrentXVal;
        e2 = ElemYVal - CurrentYVal;
        Total = sqrt(e1 * e1 + e2 * e2);
        if (Total < 4) {
          Elem[4] = CurrentXVal;
          Elem[5] = CurrentYVal;
          return [I, round(Total)];
        }
        if (Total < MaxTotal) {
          EndIndex = I;
          MaxTotal = round(Total);
        }
      }
      I += 1;
    }
    return [EndIndex, MaxTotal];
  };
  Main.FindBestMatch = function(First, Second){
    var len, K, Range;
    len = First.length;
    K = 0;
    Range = 17;
    while (K < len) {
      First[K][3] = Main.FindClosestElem(K, Range, First, Second);
      K += 1;
    }
  };
  Main.FrontCheck = function(Base0, Base1, Second){
    var ID0, ID1, Elem;
    if (Base0[4] !== null) {
      return;
    }
    ID0 = Base0[3][0];
    ID1 = Base1[3][0];
    if (ID0 !== ID1) {
      Elem = Second[ID0];
      Base0[4] = Elem[0];
      Base0[5] = Elem[1];
    }
  };
  Main.EdgeCheck = function(IndexMain, IndexSecond, Sorted, Second){
    var Base0, Base1;
    Base0 = Sorted[IndexMain];
    Base1 = Sorted[IndexSecond];
    this.FrontCheck(Base0, Base1, Second);
  };
  Main.UniqueCheck = function(Sorted, Second){
    var len, I, NumberOfSame, Base, Next, IDBase, IDNext, IndexWithLow, Distance, MovingIndexId, Elem, CurrentDistance, FromElem;
    len = Sorted.length;
    Main.EdgeCheck(len - 1, len - 2, Sorted, Second);
    len -= 2;
    I = 0;
    while (I < len) {
      NumberOfSame = 1;
      Base = Sorted[I];
      Next = Sorted[I + 1];
      IDBase = Base[3][0];
      IDNext = Next[3][0];
      if (IDBase === IDNext) {
        IndexWithLow = I;
        Distance = Base[3][1];
        while (IDBase === IDNext) {
          MovingIndexId = I + NumberOfSame;
          if (MovingIndexId > len + 1) {
            break;
          }
          Elem = Sorted[MovingIndexId];
          IDNext = Elem[3][0];
          CurrentDistance = Elem[3][1];
          if (CurrentDistance < Distance) {
            IndexWithLow = MovingIndexId;
          }
          Elem = Sorted[IndexWithLow];
          if (Elem[4] === null) {
            FromElem = Second[Elem[3][0]];
            Elem[4] = FromElem[0];
            Elem[5] = FromElem[1];
          }
          NumberOfSame += 1;
        }
        I += NumberOfSame - 2;
      } else if (Base[4] === null) {
        Elem = Second[Base[3][0]];
        Base[4] = Elem[0];
        Base[5] = Elem[1];
      }
      I += 1;
    }
  };
  Main.Switch = function(Sorted){
    var len, I, K, Elem, X;
    len = Sorted.length;
    I = 0;
    K = 0;
    while (I < len) {
      Elem = Sorted[I];
      X = Elem[4];
      if (X) {
        Elem[3] = null;
        Elem[1] = X;
        Elem[2] = Elem[5];
      } else {
        Elem[3] = true;
        Elem[1] = Elem[6];
        Elem[2] = Elem[7];
        K += 1;
      }
      Elem[4] = null;
      Elem[5] = null;
      I += 1;
    }
    return K;
  };
  Main.SetHome = function(Index, First){
    var Elem;
    Elem = First[Index];
    if (Elem[1] === null) {
      Elem[1] = Elem[6];
      Elem[2] = Elem[7];
      Elem[3] = true;
    }
  };
  Main.FindGaps = function(Sorted){
    var len, K, List, Previous, Next, Diff, N;
    len = Sorted.length - 1;
    K = 2;
    List = [];
    Previous = Sorted[0][3][0];
    Next = Sorted[1][3][0];
    while (K < len) {
      Diff = Next - Previous;
      Diff -= 1;
      if (Diff > 0) {
        N = 1;
        while (Diff) {
          List.push(Previous + 1 * N);
          N += 1;
          Diff -= 1;
        }
      }
      K += 1;
      Previous = Next;
      Next = Sorted[K][3][0];
    }
    return List;
  };
  Main.FindNulls = function(Sorted){
    var len, K, List;
    len = Sorted.length;
    K = 0;
    List = [];
    while (K < len) {
      if (Sorted[K][4] === null) {
        List.push(K);
      }
      K += 1;
    }
    return List;
  };
  Main.TestLeftOver = function(ListOfAnon, ListOfNulls, First, Second){
    var len1, K, list, len2, Total, Elem, total, I, sqrt, LowTotal, LowestID, Elem2, CurrentX, CurrentY;
    len1 = ListOfNulls.length;
    K = 0;
    list = [];
    len2 = ListOfAnon.length;
    while (K < len1) {
      Total = 0;
      Elem = First[ListOfNulls[K]];
      total = 0;
      I = 0;
      sqrt = this.sqrt;
      LowTotal = Infinity;
      LowestID = 0;
      while (I < len2) {
        Elem2 = Second[ListOfAnon[I]];
        CurrentX = Elem[1] - Elem2[0];
        CurrentY = Elem[2] - Elem2[1];
        Total = sqrt(CurrentX * CurrentX + CurrentY * CurrentY);
        if (Total < LowTotal) {
          LowTotal = Total;
          LowestID = I;
        }
        I += 1;
      }
      list.push([LowestID, this.round(LowTotal)]);
      K += 1;
    }
    console.log(_.sortBy(_.zip(ListOfNulls, list), function(x){
      return x[1][1];
    }));
  };
  Main.TrackIDs = function(First, Second){
    var Sorted;
    First = _.sortBy(First, function(x){
      return x[1];
    });
    Second = _.sortBy(Second, function(x){
      return x[0];
    });
    this.FindBestMatch(First, Second);
    Sorted = _.sortBy(First, function(x){
      return x[3][0];
    });
    Main.UniqueCheck(Sorted, Second);
    return Main.Switch(Sorted);
  };
  Main.KeepHistory = function(HistoryX, HistoryY, HistoryNull, Cloned){
    var lenC, lenH, Sorted, I, Each;
    lenC = Cloned.length;
    lenH = History.length;
    Cloned = Sorted = _.sortBy(Cloned, function(x){
      return x[0];
    });
    I = 0;
    while (I < lenC) {
      Each = Cloned[I];
      HistoryX[I].push(Each[1]);
      HistoryY[I].push(Each[2]);
      HistoryNull[I].push(Each[3]);
      I += 1;
    }
    if (HistoryX[0].length > 300) {
      I = 0;
      while (I < lenC) {
        HistoryX[I].shift();
        HistoryY[I].shift();
        HistoryNull[I].shift();
        I += 1;
      }
    }
  };
  Main.InitHistory = function(HistoryX, HistoryY, HistoryNull, len){
    var I;
    I = 0;
    while (I < len) {
      HistoryX[I] = [];
      HistoryY[I] = [];
      HistoryNull[I] = [];
      I += 1;
    }
  };
  module.exports = Main;
}).call(this);
